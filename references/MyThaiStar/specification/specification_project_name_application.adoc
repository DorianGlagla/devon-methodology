:toc: macro
toc::[]

= Specification of the _<Project_Name>_ Application =

NOTE: Content inside tags like <Project_Name> should be changed by your 
own project's information. additionally, delete all the tips before generating your document.


_<Team_Name>_ _<Team_Email>_

:toc:
:toclevels: 4
:numbered:
:website: https://www.de.capgemini.com/devonfw
:imagesdir: ./BCO_ComponentName_Management/images/


== Introduction ==

_<The first sections should provide an overview of the application and of the important concepts used in these applications. This information should enable the reader to comprehend the different artifacts that are described after that.>_


=== The _<Project_Name>_ application ===
The _<Project_Name>_ application allows users to:

_<List below the basic functionalities that your application implements for your customer or user>_

- _<Explain Functionality>_
- _<Explain Functionality>_
- _<Explain Functionality>_
- _<Explain Functionality>_

== Use Cases ==
_<This chapter contains the definition of the business logic of the application.>_


TIP: The business logic is divided between the logic present in the services and the logic present in the client. If the logic implemented in the client is more complex than the dialogue flow, a simple service call or a confirmation dialogue, the logic may also be defined in a use case or a use case function. We differentiate between use cases in the client and service use cases using the stereotypes Client UC and Service UC

=== Actors ===

_<This chapter contains the actors using your application. They may be either technical systems or things like organizational units.>_

TIP: Actors do not equal roles. Actors simply define the different organizational or business contexts in which the business logic is used. The roles and authorizations are defined seperateley, most often as part of the appendix.

TIP: Note that each actor name contains a prefix _ACR_. Each artifact in the specification contains a prefix: This allows to easily identify the type of artifact referenced in any part of the specification.

image::overview_actors.svg[caption="Figure 1: ", title="Actors", alt="Actors"]

[width="100%",options="header", cols="v,a"]
|====================
| Actor |  Description
| ACR_<Actor_Parent> |
- _<Description of the actor and its role on your application.>_
| ACR_<Actor_Name1> |
- _<Description of the actor and its role on your application.>_
| ACR_<Actor_Name2> |
- _<Description of the actor and its role on your application.>_
| ACR_<Actor_Name3> |
- _<Description of the actor and its role on your application.>_
| ACR_System_<Project_Name> |
- _<Description of the actor and its role on your application.>_
|====================

// tag::UseCases[]

=== Business Component BCO_<Component_Name>_<Action_Name> ===
_<Insert here a diagram explaining your component's use cases. Below you will find an example:>_

image::business_component_ComponentName_management.svg[caption="Figure 2: ", title="Business Component _<Component_Name>_ <Action_Name>", alt="Business Component _<Component_Name>_ <Action_Name>"]

_<Explain here your component and its functionality>_

TIP: Now you should explain each use case defined on your use case diagram.

==== Service Use Case "UC_<Action_Name>_<Component_Name>" ====


[cols="v,v" options=compact]
|====
2+| _<Explain here the functionalities of this use case>_
|Actors | _<List the actors involved in this use case>_  
|Usage | _<Type of event that triggered it: "Automatic" if it was the system, or "Manual" if it was a user >_
|Precondition | _<List the conditions or events needed for executing this use case>_
|====

_<List below the execution workflow followed by this use case.>_

.Standard workflow: _<Event_Name1>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

.Alternative workflow: _<Event_Name2>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

TIP:  If this use case contains sub-use cases, then state their workflows too. For instance, manage order contains: find order, save order and delete order.

==== Client Use Case "UC_Create_<Component_Name>" ====

TIP: Make distinction between use cases related to clients (or users) and the ones related to the system.

[cols="v,v" options=compact]
|====
2+| _<Explain here the functionalities of this use case related to the client or user>_

|Actors | _<List the actors involved in this use case>_ 
|Usage | _<Type of event that triggered it: "Automatic" if it was the system, or "Manual" if it was a user >_
|Preconditions |
_<List the conditions or events needed for executing this use case>_
|====

_<List below the execution workflow followed by this use case.">_

.Standard workflow: _<Event_Name1>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

.Alternative workflow: _<Event_Name2>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

// end::UseCases[]

== Data Model ==
// tag::DataModel[]

_<This chapter contains the data model of the application.>_

TIP: This data model is primarily defined by diagrams. Textual documentation 
is added for the entity types, attributes and relations, for which the diagrams 
are not sufficient as documentation. This should be the exception

TIP: There is not only a data model for data stored in a database. If necessary, 
transient internal data models may also be defined in this chapter.


=== Model Component MCO_<Component_Name> ===
_<Insert here a diagram explaining the data model of your component. It is normally
 a class diagram that defines the attributes of each component and the entities 
 involved. See below an example.>_

image::mco_ComponentName.svg[caption="Figure 3: ", title="Model Component MCO_<Component_Name>", alt="Model Component MCO_<Component_Name>"]

TIP: Use the sufix ATT_ for defining attributes, entities with ETY_ and MCO_ for model components.

_<List below the entities shown on the diagram:>_

==== Entity Type ETY_<Entity_Name1> ====
_<Explain here the attributes of this entity, what encapsulates and in which case it is needed.>_

==== Entity Type ETY_<Entity_Name2> ====
_<Explain here the attributes of this entity, what encapsulates and in which case it is needed.>_

// end::DataModel[]


== Dialogue ==

_<This chapter contains the description of the user interface.>_

_<List below all the dialogues of your application.>_

- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_
- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_
- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_
- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_

TIP: The client flows are specified as dialogues and screens. Dialogues contain the flow between the screens. In current clients, the same screens are used in very different forms for different purposes. In this case, one "dialogue screen" may be represented in multiple screens in the documentation.

TIP: The screens can be documented mostly by mockups or screenshots. The different elements of the screens need to be documented if they are not self explanatory or invoke any kind of business functionality.

=== Dialogue areas and mechanisms ===

_<This chapter contains cross-sectional elements and mechanisms of the client.>_

TIP: Cross-sectional topics do not need to be documented for each screen. They can be documented cross-sectional.

==== _<Dialogue_Name>_ ====

_<Explain briefly the purpose of your dialogue.>_

_<Insert here a figure showing the dialogue.>_

It contains

- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_
- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_
- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_
- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_

_<If necessary, list below the user interaction with this dialogue.>_

. _<Explain first step of user interaction.>_
. _<Explain second step of user interaction.>_
. _<Explain third step of user interaction.>_
.. _<Explain system response to the user if everything went well.>_
.. _<Explain system response to the user if something went wrong.>_

TIP: Not every dialogue has to be documented in the same way, it will depend on what you think is important.


=== Dialogue DIA_<Dialogue_Name> ===

The dialogue flow of this dialogue is shown in the next image:

image::DIA_Main_Screen_Name.svg[caption="Figure 3: ", title="DIA_<Dialogue_Name>", alt="DIA_<Dialogue_Name>"]

_<Briefly explain the purpose of this dialogue.>_

TIP: Now you should document every screen and dialogue that involves the dialogue you just explained. Repeat this process for every important dialogue.

==== Screen SCR_Main_Screen ====

_<Insert here a figure showing the screen.>_

_<List below the dialogues that are entered from this screen:>_

- DIA_<Dialogue_Name1> is reached using the link _<Link_Name>_.
- DIA_<Dialogue_Name2> is reached using the link _<Link_Name>_.
- DIA_<Dialogue_Name3> and DIA_<Dialogue_Name4> are reached by their corresponding links for users with the role _<Role_Name>_.

_<Explain here how this screen can be reached.>_

==== Screen SCR_<Screen_Name1> ====

_<Insert here a figure showing the screen.>_

_<Briefly explain the purpose of this screen.>_

_<If necessary, list below user interaction with this dialogue.>_

. _<Step 1 of interaction.>_
. _<Step 2 of interaction.>_
. _<Step 3 of interaction.>_
. _<Step 4 of interaction.>_


== External Interfaces ==
// tag::ExternalInterfaces[]


=== External Interface EIF_<Action_Name>_<Component_Name> ===
_<This section defines external interfaces required by the application or provided by the application.>_

TIP: All services provided by the server application are documented here. If services 
are quite simple like CRUD (Create, Read, Update, Delete) services, they will be defined in diagrams alone.
Additional documentation is supplied where needed.

TIP: If an external interface is already defined and documented (most probably in the sending or receiving system),
 it does not need to be documented again: A reference to the existing documentation is sufficient. This documentation 
 may even be (within limits) technical. The benefit is, aside from the effort to document the interface, to have a 
 single source of truth for the interface.

_<Insert here a diagram describing the external interfaces like the example showed below.>_

image::eif_manage_ComponentName.svg[caption="Figure 4: ", title="External Interface EIF_<Action_Name>_<Component_Name>", alt="External Interface EIF_<Action_Name>_<Component_Name>"]

This external interface provides the following operations using the different
interface entity types:

- _<Event_Name1>_: See UC_<Action_Name>_<Component_Name>, Scenario _<Event_Name1>_ .
- _<Event_Name2>_: See UC_<Action_Name>_<Component_Name>, Scenario _<Event_Name2>_ .
- _<Event_Name3>_: See UC_<Action_Name>_<Component_Name>, Scenario _<Event_Name3>_ .

// end::ExternalInterfaces[]


== Appendix ==

TIP: The appendix contains information not provided in the introduction or the artifacts of the specification method. It may contain, among other contents: +
 +
- roles and authorization details +
- business logging details +
- static data +
- business logging and protocol information +

=== Terms and definitions ===

[width="100%",options="header"]
|====================
| Term |  Definition
| _<Term_Name1>_ |  _<Term_Definition>_
| _<Term_Name2>_ |  _<Term_Definition>_
| _<Term_Name3>_ |  _<Term_Definition>_
|====================
