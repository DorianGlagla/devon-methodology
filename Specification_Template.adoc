:toc: macro
toc::[]

= Specification of the _<Project_Name>_ Application =

NOTE: *_Handling of notes_*: _Content inside tags like <Project_Name> should be changed by your
own project's information. additionally, delete all the tips before generating your document._

NOTE: *_Content of a specification_*: _A specification contains a formalized desciption of the currently implemented portion of the application. While a story or epic describes necessary implementations to be done in the future, a specification describes the system as a whole in the current implementation state._

[NOTE]
====
*_Formality of the artifacts_*: _The contents of a system are described in the form of focused and formalized artifacts (e.g. use cases, entities, interfaces). This is done in order to_

- _reduce the complexity of the description._
- _reduce the redundancy of the description and therefore contradictions._
- _increase the level of detail and therefore the correctness per artifact._

The artifacts will in many cases directly relate to the implementation, e.g. business components to packages, use cases to classes, entities to tables. Therefore, this structure enables the establishment of a ubiquitous language in the tradition of domain driven design.
====

[NOTE]
====
*_Usage of prefixes_*: _The artifacts (use cases, screens, interfaces, ...) of a specification shall be given a unique name (without spaces) prefixed by the type of the artifact, e.g. "ETY_Guest_Personal_Data" for an artifact of the type "Entity", where each instance of the entity contains the personal data of one guest._

.The following entity types are typically used:
- _ACO: An APPLICATION COMPONENT, a (mostly) independent part of the functionality of an application, e.g. "ACO_Customer_Management", "ACO_Invoice_Handling"_
- _UC: A USE CASE describing the functionality of an application, grouped in application components._
- _ACT: An ACTOR using a use case, invoking an interface etc. May be human or automated._
- _AFU: An APPLCATION FUNCTION. While a use case is typically invoked or used by an actor, an application function is a part of the logic of a use case isolated in a seperate function in order to reduce redundancy or the complexity of use cases._
- _BAT: A BATCH is invoked in defined intervals (minutes, months, years) to perform functionality on a large amount of data, e.g. deleting obsolete data.
- _MCO: A MODEL COMPONENT: Entities are grouped in model components. Each model component is controlled by exactly one application component. Most often, these components correspond to each other._
- _ETY: An ENTITY containing (most often persisted) information (see TODO)_
- _ATT: An ATTRIBUTE inside an entity. It contains a name, a type, a description and information about its multiplicity._
- _DTY: The DATA TYPE of an attribute inside an entity._
- _DIA: A DIALOGUE FLOW, typically supporting the functionality of a use case._
- _SCR: A SCREEN inside a DIALOGUE FLOW, representing one page or one state of a page._
- _PRI: A formatted PRINTOUT. Also used to define the structure of input data._
- _EIF: An EXTERNAL INTERFACE of the system, either providing a service or using an external service._
- _EIE: An ENTITY of an EXTERNAL INTERFACE, analogous to an entity of the data model._
- _EIA: An ATTRIBUTE of an EXTERNAL INTERFACE._
- _NFR: A NON-FUNCTIONAL REQUIREMENT of the system._

_The usage of unique names without spaces and of these prefixes for artifacts allows to directly identify an artifact and its type._
====

_<Team_Name>_ _<Team_Email>_

:toc:
:toclevels: 4
:numbered:
:website: https://www.de.capgemini.com/devonfw
:imagesdir: ./extracted-media/mediaSpecificationTemplate
:imagesComponentNameManagement: /extracted-media/mediaSpecificationTemplate/BCO_ComponentName_Managament_Images


== Introduction ==

_The first sections should provide an overview of the application and of the important concepts used in these applications. This information should enable the reader to comprehend the different artifacts that are described after that._

NOTE: *_Purpose of the chapter_*: _This chapter must provide the context to understand the very specific artifacts (use cases, entities) defined in the following chapters. All cross cutting concepts should be defined here or in the appendix (and then be referenced here)._

NOTE: *_Structure_*: _There are no rules for the structure of the introductory chapters. The focus should be to present the context with as much didactics as possible._


=== The _<Project_Name>_ application ===
The _<Project_Name>_ application allows users to:

_<List below the basic functionalities that your application implements for your customer or user>_

- _<Explain Functionality>_
- _<Explain Functionality>_
- _<Explain Functionality>_
- _<Explain Functionality>_

== Use Cases ==
_This chapter contains the definition of the business logic of the application. The business logic is split into business components. Each business component contains the use cases, use case functions and the batches of this business component._

=== Actors ===

_This chapter contains the actors using your application. They may be e.g. technical systems or organizational units. The benefit of defining actors is to use them in use cases, dialogues and interfaces to uniformly define who interacts with the system in what manner._

NOTE: *_Actors and roles_*: _Actors do not equal roles. Actors simply define the different organizational or business contexts in which the business logic is used. The roles and authorizations are defined seperateley, most often as part of the appendix._

NOTE: *_Granularity of actors_*: _Do not define actors in a granularity that is too fine. Group organizational units it their interaction with the system is uniform. Use the actor description to define the underlying organizational units, and actors themselves to define the different kinds of interaction with the system._

image::overview_actors.svg[caption="Figure 1: ", title="Actors", alt="Actors"]

[width="100%",options="header", cols="v,a"]
|====================
| Actor |  Description
| ACR_<Actor_Parent> |
- _<Description of the actor and its role on your application.>_
| ACR_<Actor_Name1> |
- _<Description of the actor and its role on your application.>_
| ACR_<Actor_Name2> |
- _<Description of the actor and its role on your application.>_
| ACR_<Actor_Name3> |
- _<Description of the actor and its role on your application.>_
| ACR_System_<Project_Name> |
- _<Description of the actor and its role on your application.>_
|====================

// tag::UseCases[]

=== Business Component BCO_<Component_Name>_<Action_Name> ===

[NOTE]
====
*_Business Components_*: _The business logic of an application is typically quite complex. In order to specify and implement it in a sustainable way, the business logic needs to be structured. As a first step, different areas of functionality that are largely independent from each other are identified. These areas shall be business components. In the implemented system, functionality of one component may only access the functionality of other components using a well defined interface. This keeps a growing complexity at bay and allows for a focused definition of the functionality._


_Examples for business components could be business logging, printout creation, order handling or user administration._
====

NOTE: *_Business components and data_*: _Typically, a business component controls a number of entities in the database (the entities of a corresponding_ *_model component_*). _This data is only written (and in many cases only read) by the functionality of the business component. This is called the secrecy principle of a business component: Only the component itself knows about the details of its functionality and its data, making the whole application thereby easier to maintain._


image::business_component_ComponentName_management.svg[caption="Figure 2: ", title="Business Component _<Component_Name>_ <Action_Name>", alt="Business Component _<Component_Name>_ <Action_Name>"]

_Explain here your component and its functionality_

_You should explain each use case defined on your use case diagram._

==== Service Use Case "UC_<Action_Name>_<Component_Name>" ====

NOTE: *_Use Cases_*: _The functionality of a business component is still to complex to define in one artifact. Therefore, independent parts of the functionality need to be identified. Typically, this is done by identifying different ways to interact with the system. Each usage of the system that provides a benefit for a (potentially non-human) actor may be a_ *_use case_* _of the system._ 

NOTE: *_Client (service) and server use cases_*: _The business logic is divided between the logic present in the services and the logic present in the client. If the logic implemented in the client is more complex than the dialogue flow, a simple service call or a confirmation dialogue, the logic may also be defined in a use case or a use case function. We differentiate between use cases in the client and service use cases using the stereotypes Client UC and Service UC_


[cols="v,v" options=compact]
|====
2+| _<Explain here the functionalities of this use case>_
|Actors | _<List the actors involved in this use case>_
|Usage | _<Type of event that triggered it: "Automatic" if it was the system, or "Manual" if it was a user >_
|Precondition | _<List the conditions or events needed for executing this use case>_
|====

_<List below the execution workflow followed by this use case.>_

.Standard workflow: _<Event_Name1>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

.Alternative workflow: _<Event_Name2>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

TIP:  If this use case contains sub-use cases, then state their workflows too. For instance, manage order contains: find order, save order and delete order.

==== Client Use Case "UC_Create_<Component_Name>" ====

TIP: Make distinction between use cases related to clients (or users) and the ones related to the system.

[cols="v,v" options=compact]
|====
2+| _<Explain here the functionalities of this use case related to the client or user>_

|Actors | _<List the actors involved in this use case>_
|Usage | _<Type of event that triggered it: "Automatic" if it was the system, or "Manual" if it was a user >_
|Preconditions |
_<List the conditions or events needed for executing this use case>_
|====

_<List below the execution workflow followed by this use case.">_

.Standard workflow: _<Event_Name1>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

.Alternative workflow: _<Event_Name2>_
. _<Explain step>_
. _<Explain step>_
. _<Explain step>_

// end::UseCases[]

== Data Model ==
// tag::DataModel[]

_<This chapter contains the data model of the application.>_

TIP: This data model is primarily defined by diagrams. Textual documentation
is added for the entity types, attributes and relations, for which the diagrams
are not sufficient as documentation. This should be the exception

TIP: There is not only a data model for data stored in a database. If necessary,
transient internal data models may also be defined in this chapter.


=== Model Component MCO_<Component_Name> ===
_<Insert here a diagram explaining the data model of your component. It is normally
 a class diagram that defines the attributes of each component and the entities
 involved. See below an example.>_

image::mco_ComponentName.svg[caption="Figure 3: ", title="Model Component MCO_<Component_Name>", alt="Model Component MCO_<Component_Name>"]

TIP: Use the sufix ATT_ for defining attributes, entities with ETY_ and MCO_ for model components.

_<List below the entities shown on the diagram:>_

==== Entity Type ETY_<Entity_Name1> ====
_<Explain here the attributes of this entity, what encapsulates and in which case it is needed.>_

==== Entity Type ETY_<Entity_Name2> ====
_<Explain here the attributes of this entity, what encapsulates and in which case it is needed.>_

// end::DataModel[]


== Dialogue ==

_<This chapter contains the description of the user interface.>_

_<List below all the dialogues of your application.>_

- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_
- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_
- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_
- *_<Dialogue_Name>_* _<Describe briefly the dialogue.>_

TIP: The client flows are specified as dialogues and screens. Dialogues contain the flow between the screens. In current clients, the same screens are used in very different forms for different purposes. In this case, one "dialogue screen" may be represented in multiple screens in the documentation.

TIP: The screens can be documented mostly by mockups or screenshots. The different elements of the screens need to be documented if they are not self explanatory or invoke any kind of business functionality.

=== Dialogue areas and mechanisms ===

_<This chapter contains cross-sectional elements and mechanisms of the client.>_

TIP: Cross-sectional topics do not need to be documented for each screen. They can be documented cross-sectional.

==== _<Dialogue_Name>_ ====

_<Explain briefly the purpose of your dialogue.>_

_<Insert here a figure showing the dialogue.>_

It contains

- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_
- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_
- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_
- _<Explain each element of the dialogue and if its a link, to which screen it is directing to.>_

_<If necessary, list below the user interaction with this dialogue.>_

. _<Explain first step of user interaction.>_
. _<Explain second step of user interaction.>_
. _<Explain third step of user interaction.>_
.. _<Explain system response to the user if everything went well.>_
.. _<Explain system response to the user if something went wrong.>_

TIP: Not every dialogue has to be documented in the same way, it will depend on what you think is important.


=== Dialogue DIA_<Dialogue_Name> ===

The dialogue flow of this dialogue is shown in the next image:

image::DIA_Main_Screen_and_User_Management.svg[caption="Figure 3: ", title="DIA_<Dialogue_Name>", alt="DIA_<Dialogue_Name>"]

_<Briefly explain the purpose of this dialogue.>_

TIP: Now you should document every screen and dialogue that involves the dialogue you just explained. Repeat this process for every important dialogue.

==== Screen SCR_Main_Screen ====

_<Insert here a figure showing the screen.>_

_<List below the dialogues that are entered from this screen:>_

- DIA_<Dialogue_Name1> is reached using the link _<Link_Name>_.
- DIA_<Dialogue_Name2> is reached using the link _<Link_Name>_.
- DIA_<Dialogue_Name3> and DIA_<Dialogue_Name4> are reached by their corresponding links for users with the role _<Role_Name>_.

_<Explain here how this screen can be reached.>_

==== Screen SCR_<Screen_Name1> ====

_<Insert here a figure showing the screen.>_

_<Briefly explain the purpose of this screen.>_

_<If necessary, list below user interaction with this dialogue.>_

. _<Step 1 of interaction.>_
. _<Step 2 of interaction.>_
. _<Step 3 of interaction.>_
. _<Step 4 of interaction.>_


== External Interfaces ==
// tag::ExternalInterfaces[]


=== External Interface EIF_<Action_Name>_<Component_Name> ===
_<This section defines external interfaces required by the application or provided by the application.>_

TIP: All services provided by the server application are documented here. If services
are quite simple like CRUD (Create, Read, Update, Delete) services, they will be defined in diagrams alone.
Additional documentation is supplied where needed.

TIP: If an external interface is already defined and documented (most probably in the sending or receiving system),
 it does not need to be documented again: A reference to the existing documentation is sufficient. This documentation
 may even be (within limits) technical. The benefit is, aside from the effort to document the interface, to have a
 single source of truth for the interface.

_<Insert here a diagram describing the external interfaces like the example showed below.>_

image::eif_manage_ComponentName.svg[caption="Figure 4: ", title="External Interface EIF_<Action_Name>_<Component_Name>", alt="External Interface EIF_<Action_Name>_<Component_Name>"]

This external interface provides the following operations using the different
interface entity types:

- _<Event_Name1>_: See UC_<Action_Name>_<Component_Name>, Scenario _<Event_Name1>_ .
- _<Event_Name2>_: See UC_<Action_Name>_<Component_Name>, Scenario _<Event_Name2>_ .
- _<Event_Name3>_: See UC_<Action_Name>_<Component_Name>, Scenario _<Event_Name3>_ .

// end::ExternalInterfaces[]


== Appendix ==

TIP: The appendix contains information not provided in the introduction or the artifacts of the specification method. It may contain, among other contents: +
 +
- roles and authorization details +
- business logging details +
- static data +
- business logging and protocol information +

=== Terms and definitions ===

[width="100%",options="header"]
|====================
| Term |  Definition
| _<Term_Name1>_ |  _<Term_Definition>_
| _<Term_Name2>_ |  _<Term_Definition>_
| _<Term_Name3>_ |  _<Term_Definition>_
|====================
